package DaySeven

#load "helpers"

use core {*}
use helpers {*}

Solve :: () -> void {
    card_map := Map.literal(u8, i32, .[
        .{'1', 1}, .{'2', 2}, .{'3', 3}, .{'4', 4},
        .{'5', 5}, .{'6', 6}, .{'7', 7}, .{'8', 8},
        .{'9', 9}, .{'T', 10}, .{'J', 11}, .{'Q', 12}, 
        .{'K', 13}, .{'A', 14}
    ]);

    five: [..] str;
    four: [..] str;
    full: [..] str;
    three: [..] str;
    two_pair: [..] str;
    one_pair: [..] str;
    highest: [..] str;

    hand_map: Map([] u8, i32);

    for line: GetContents("input/day_seven.txt") do
        map.put(
            &hand_map, 
            string.split(line, 32)[0], 
            ~~conv.parse_int(string.split(line, 32)[1])
        );

    hands := hand_map->as_iter()
        |> iter.map(hand => hand.key)
        |> iter.collect();

    // Get Five of a Kind
    for x: 0 .. hands.length do CheckKind(hands[x], x, 5);
    for x: five do array.remove(&hands, x);

    // Get Four of a Kind
    for x: 0 .. hands.length do CheckKind(hands[x], x, 4);
    for x: four do array.remove(&hands, x);

    // Get Full Houses
    for x: 0 .. hands.length do CheckFull(hands[x], x);
    for x: full do array.remove(&hands, x);

    // Get Three of Kind
    for x: 0 .. hands.length do CheckKind(hands[x], x, 3);
    for x: three do array.remove(&hands, x);

    // Get Pairs
    for x: 0 .. hands.length do CheckPair(hands[x], x);
    for x: two_pair do array.remove(&hands, x);
    for x: one_pair do array.remove(&hands, x);

    // Get Highest
    println(hands);
    for x: hands do highest << x;

    array.free(&hands);

    all_hands: [..][] str;    
    all_hands << five;
    all_hands << four;
    all_hands << full;
    all_hands << three;
    all_hands << two_pair;
    all_hands << one_pair;
    all_hands << highest;

    SortHands(all_hands, &card_map);
    PartOne(all_hands, &hand_map);

    CheckKind :: macro (h: [] u8, idx: i32, kind: i32) -> void {
        for card: card_map->as_iter() {
            count := 0;
            for c: h do if c == card.key do count += 1;
            if kind == 5 && count == 5 do five << h; 
            if kind == 4 && count == 4 do four << h; 
            if kind == 3 && count == 3 do three << h;
        }
    }
    CheckFull :: macro (h: [] u8, idx: i32) -> bool {
        current: u8 = '\0';

        //Check for Three of Kind
        for card: card_map->as_iter() {
            count := 0;
            for c: h do if c == card.key do count += 1;
            if count == 3 { current = card.key; break; }
        }

        //Check for Two of Kind if Three of Kind Found
        if current != '\0' {
            for card: card_map->as_iter() {
                count := 0;
                for c: h do if c == card.key && current != c do count += 1;
                if count == 2 do full << h;
            }
        }
    }
    CheckPair :: macro (h: [] u8, idx: i32) -> bool {
        current: u8 = '\0';

        //Check for One Pair
        for card: card_map->as_iter() {
            count := 0;
            for c: h do if c == card.key do count += 1;
            if count == 2 { current = card.key; break; }
        }

        //Check for Possible Two Pair, if not add to one_pair
        if current != '\0' {
            pair := false;
            for card: card_map->as_iter() {
                count := 0;
                for c: h do if c == card.key && current != c do count += 1;
                if count == 2 { 
                    two_pair << h;
                    pair = true;
                }
            }
            if pair == false do one_pair << h;
        }
    }
}

SortHands :: (hands: [..][] str, card_map: &Map(u8, i32)) -> void {
    for strength: hands {
        for x: 0 .. strength.length - 1 {
            swapped := false;
            for i: 0 .. strength.length - 1 {
                for j: 0 .. 5 {
                    first := card_map->get(strength[i][j])?;
                    second := card_map->get(strength[i+1][j])?;
                    if first != second {
                        if first < second {
                            tmp := strength[i];
                            strength[i] = strength[i+1];
                            strength[i+1] = tmp;
                            swapped = true;
                        }
                        break;
                    }
                }
            }
            if swapped == false do break;
        }
    }
}

PartOne :: (hands: [..][] str, hand_map: &Map([] u8, i32)) -> void {
    total: i64 = 0;
    rank := 1000;
    tmp := 0;
    for strength: hands {
        tmp += strength.length;
        for h: strength {
            total += ~~(rank * hand_map->get(h)?);
            rank -= 1;
        }
    }

    println(tmp);
    printf("Part 1: {}\n", total);
}

PartTwo :: () -> u32 {
    return 0;
}